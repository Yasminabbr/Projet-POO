#include <stdlib.h>

#define TAILLE_BLOC 256

typedef struct Bloc {
    char data[TAILLE_BLOC]; // Contenu du bloc
} Bloc;


void initialiserMemoire(FILE *fichier, int nombreBlocs) {
    // Création d'un bloc vide (rempli de zéros)
    char *blocVide = calloc(TAILLE_BLOC, sizeof(char));

    // Remplir chaque bloc de mémoire avec des zéros
    for (int i = 0; i < nombreBlocs; i++) {
        fseek(fichier, i * TAILLE_BLOC, SEEK_SET);
        fwrite(blocVide, sizeof(char), TAILLE_BLOC, fichier);
    }

    free(blocVide);
    printf("Mémoire secondaire initialisée avec %d blocs de taille %d octets.\n", nombreBlocs, TAILLE_BLOC);
}


void afficherEtatMemoire(FILE *fichier, int nombreBlocs) {
    // Allocation d'un bloc de taille TAILLE_BLOC pour lire les données
    char *bloc = malloc(TAILLE_BLOC * sizeof(char));

    // Parcours de chaque bloc pour vérifier s'il est vide ou occupé
    for (int i = 0; i < nombreBlocs; i++) {
        fseek(fichier, i * TAILLE_BLOC, SEEK_SET);
        fread(bloc, sizeof(char), TAILLE_BLOC, fichier);

        int estVide = 1;  // Par défaut, on suppose que le bloc est vide

        // Vérifier si le bloc est vide en parcourant chaque octet
        for (int j = 0; j < TAILLE_BLOC; j++) {
            if (bloc[j] != 0) {  
                estVide = 0;      // Le bloc est occupé
                break;            
            }
        }

        // Affichage de l'état du bloc
        if (estVide) {
            printf("Bloc %d : est vide\n", i);  // Le bloc est vide 
        } else {
            printf("Bloc %d : est occupé\n", i);  // Le bloc est occupé 
        }
    }

    free(bloc);
}


void reinitialiserBloc(FILE *fichier, int posBloc) {
    // Création d'un bloc vide
    char *blocVide = calloc(TAILLE_BLOC, sizeof(char));

    // Réinitialiser le bloc à la position spécifiée (remplir de zéros)
    fseek(fichier, posBloc * TAILLE_BLOC, SEEK_SET);
    fwrite(blocVide, sizeof(char), TAILLE_BLOC, fichier);

    free(blocVide);
    printf("Bloc %d réinitialisé.\n", posBloc);
}


void compactageMemoire(FILE *fichier, int nombreBlocs) {
    // Allocation d'un bloc pour lire les données
    char *bloc = malloc(TAILLE_BLOC * sizeof(char));
    int ecriture = 0;  // Index pour l'écriture des blocs non vides

    // Parcours des blocs
    for (int lecture = 0; lecture < nombreBlocs; lecture++) {
        fseek(fichier, lecture * TAILLE_BLOC, SEEK_SET);
        fread(bloc, sizeof(char), TAILLE_BLOC, fichier);

        int estVide = 1;  // Par défaut, on suppose que le bloc est vide

        // Vérifier si le bloc est vide
        for (int j = 0; j < TAILLE_BLOC; j++) {
            if (bloc[j] != 0) {  
                estVide = 0;      // Le bloc est occupé
                break;            
            }
        }

        // Si le bloc n'est pas vide, on le déplace
        if (!estVide) {
            if (ecriture != lecture) {  // Si l'index d'écriture est différent de l'index de lecture
                // Déplacer le bloc non vide vers la position d'écriture
                fseek(fichier, ecriture * TAILLE_BLOC, SEEK_SET);
                fwrite(bloc, sizeof(char), TAILLE_BLOC, fichier);

                // Réinitialiser l'ancien bloc qui était déplacé
                fseek(fichier, lecture * TAILLE_BLOC, SEEK_SET);
                fwrite((char[TAILLE_BLOC]){0}, sizeof(char), TAILLE_BLOC, fichier);
            }
            ecriture++;  // Incrémenter l'index d'écriture après avoir déplacé un bloc
        }
    }

    free(bloc);
    printf("Compactage effectué.\n");
}

void viderMemoire(FILE *fichier, int nombreBlocs) {
    // Création d'un bloc vide
    char *blocVide = calloc(TAILLE_BLOC, sizeof(char));

    // Vider tous les blocs en les réinitialisant à zéro
    for (int i = 0; i < nombreBlocs; i++) {
        fseek(fichier, i * TAILLE_BLOC, SEEK_SET);
        fwrite(blocVide, sizeof(char), TAILLE_BLOC, fichier);
    }

    free(blocVide);
    printf("Mémoire secondaire vidée.\n");
}
